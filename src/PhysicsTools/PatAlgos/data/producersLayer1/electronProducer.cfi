
module allLayer1Electrons = PATElectronProducer {

  ### General configurables
  InputTag electronSource    = allLayer0Electrons       # clean layer 0 electrons
  bool     embedGsfTrack     = false                    # whether to embed in AOD externally stored gsf track
  bool     embedSuperCluster = false                    # whether to embed in AOD externally stored supercluster
  bool     embedTrack        = false                    # whether to embed in AOD externally stored track

  ### MC matching configurables
  bool     addGenMatch       = true                     # switch on/off matching to generator level
  InputTag genParticleMatch  = electronMatch            # Association between electrons and generator particles
  
  ### Trigger matching configurables
  bool      addTrigMatch     = true                     # switch on/off matching to trigger primitives
  VInputTag trigPrimMatch    = { electronTrigMatchHLT1ElectronRelaxed,
                                 electronTrigMatchCandHLT1ElectronStartup }
                                                        # trigger primitive sources to be used for the matching

  ### resolution configurables
  bool     addResolutions    = true                     # switch on/off the resolution calculation
  bool     useNNResolutions  = false                    # use the neural network approach?
  string   electronResoFile  = "PhysicsTools/PatUtils/data/Resolutions_electron.root"
                                                        # input root file for the resolution functions

  InputTag tracksSource      = generalTracks    # tracks to be used for LR

  ### isolation configurables
  PSet isolation   = {
     PSet tracker = {
        // input IsoDeposit
        InputTag src = layer0ElectronIsolations:eleIsoDepositTk
        // parameters to compute isolation (Egamma POG defaults)
        double  deltaR = 0.3
        vstring vetos = {"0.015",            # Inner DR Veto
                         "Threshold(1.0)"}   # Minimum Tk Pt
        bool skipDefaultVeto = true
     }
     PSet ecal = { 
        // input IsoDeposit
        InputTag src = layer0ElectronIsolations:eleIsoDepositEcalFromClusts
        // parameters to compute isolation (Egamma POG defaults)
        double  deltaR = 0.4
        vstring vetos = {"EcalBarrel:0.040",                                      # Barrel (|eta| < 1.479)
                         "EcalBarrel:RectangularEtaPhiVeto(-0.01,0.01,-0.5,0.5)", # 
                        "EcalEndcaps:0.070",                                      # Endcaps
                        "EcalEndcaps:RectangularEtaPhiVeto(-0.02,0.02,-0.5,0.5)"} # 
        bool skipDefaultVeto = true
     }
     #other option, using eleIsoDepositEcalSCVetoFromClust
     #PSet ecal = { 
     #   // input IsoDeposit
     #   InputTag src = layer0ElectronIsolations:eleIsoDepositEcalFromClusts
     #   // parameters to compute isolation (Egamma POG defaults)
     #   double  deltaR = 0.4
     #   vstring vetos = {} # no veto, already done with SC
     #   bool skipDefaultVeto = true
     #}
     PSet hcal = { 
        // input IsoDeposit
        InputTag src = layer0ElectronIsolations:eleIsoDepositHcalFromTowers
        // parameters to compute isolation (Egamma POG defaults)
        double deltaR = 0.4
        bool skipDefaultVeto = true # no inner cone veto
     }
     VPSet user = { }
  }
  PSet isoDeposits = {  
        InputTag tracker = layer0ElectronIsolations:eleIsoDepositTk
        InputTag ecal    = layer0ElectronIsolations:eleIsoDepositEcalFromClusts
        InputTag hcal    = layer0ElectronIsolations:eleIsoDepositHcalFromTowers
  }

  ### electron ID configurables
  bool     addElectronID     = false                     # switch on/off the electron ID info addition
  InputTag electronIDSource  = electronId               # label of the electron ID info source
  bool     addElectronIDRobust     = false               # switch on/off the adding of additional electron id info, from the "robust cuts-based" producer            
  InputTag electronIDRobustSource  = electronIdRobust   # label for the robust cuts-based producer (should be just a clone of previous)

}
